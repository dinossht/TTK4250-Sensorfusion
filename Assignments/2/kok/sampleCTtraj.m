function [X, Z] = sampleCTtraj(n, Ts, xbar0, P0, q, r)
    % samples a state trajectory X with measurements Z for n time steps of
    % size Ts. The initial state is sampled from a Gaussian with mean xbar0
    % and covariance P0. The state trasitions follows that of the CV model
    % where the linear acceleration covariance is specified by q(1) and the
    % rotational acceleration has covariance q(2). The measurements are
    % generated by sampling a Gaussian with mean x(1:2) and covarance r *
    % eye(2).
    
    % some limits
    maxSpeed = 20;
    maxTurn = pi/4;
    
    % sqrt(covs)
    cholR = sqrt(r) * eye(2);
    Q = [q(1) * [   Ts^3/3, 0,      Ts^2/2,	0,     ;
                    0,      Ts^3/3, 0,    	Ts^2/2 ;
                    Ts^2/2, 0,      Ts,   	0,     ;
                    0,      Ts^2/2, 0,    	Ts,    ],   zeros(4,1);
                    zeros(1, 4),                        q(2) * Ts];
    cholQ = chol(Q)';
    
    % allocate
    Z = zeros(2, n);
    X = zeros(5, n);
    
    % initialize
    X(:, 1) = xbar0 + chol(P0)' * randn(5,1);
    Z(:, 1) = X(1:2, 1) + cholR * randn(2,1);
    
    for i = 1:n
        % limit speed
        maxSpeedRatio = (X(3, i)^2 + X(4, i)^2)/(maxSpeed^2);
        if maxSpeedRatio > 1
            X(3:4, i) = X(3:4, i) /sqrt(maxSpeedRatio);
        end
        % limit turn rate
        if abs(X(5, i)) > maxTurn
            X(5, i) = maxTurn * sign(X(5));
        end
        
        % measurement
        Z(:, i) = X(1:2, i) + cholR * randn(2, 1);
        
        % predict
        if i < n
            X(:,i + 1) = f_m2_withT(X(:, i), Ts) + cholQ * randn(5, 1);
        end
        
    end
end


function xout = f_m2_withT(x,T)
    if(abs(x(5)) > 0.0001)
        xout = [x(1) + sin(T * x(5)) * x(3) / x(5) - (1 - cos(T * x(5))) * x(4) / x(5);
                x(2) + (1 - cos(T * x(5))) * x(3) / x(5) + sin(T * x(5)) * x(4) / x(5);
                cos(T * x(5)) * x(3) - sin(T * x(5)) * x(4);
                sin(T * x(5)) * x(3) + cos(T * x(5)) * x(4);...
                x(5)];
    else
        xout = [x(1) + T*x(3); x(2) + T*x(4); x(3); x(4); 0];
    end
end